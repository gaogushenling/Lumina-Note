import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FileText, 
  Edit3, 
  Eye, 
  Folder, 
  Hash,
  AlertCircle,
  CheckCircle2,
  Flame,
  Info,
  Zap
} from 'lucide-react';

// --- Tailwind Loader ---
const useTailwind = () => {
  useEffect(() => {
    if (window.tailwind) return;
    const script = document.createElement('script');
    script.src = "https://cdn.tailwindcss.com";
    script.async = true;
    document.head.appendChild(script);
  }, []);
};

// --- KaTeX Loader ---
const useKaTeX = () => {
  const [isLoaded, setIsLoaded] = useState(false);
  useEffect(() => {
    if (window.katex) { setIsLoaded(true); return; }
    const link = document.createElement('link');
    link.href = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css";
    link.rel = "stylesheet";
    document.head.appendChild(link);
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js";
    script.onload = () => setIsLoaded(true);
    document.head.appendChild(script);
  }, []);
  return isLoaded;
};

// --- SVG Icons Map ---
const getCalloutIcon = (type) => {
  const icons = {
    note: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>',
    info: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>',
    tip: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.5-3.3"/></svg>',
    success: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
    warning: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></svg>',
    danger: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><line x1="15" x2="9" y1="9" y2="15"/><line x1="9" x2="15" y1="9" y2="15"/></svg>',
    example: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>'
  };
  return icons[type] || icons.note;
};

const INITIAL_CONTENT = `## ✨ 优雅的内联样式

我们通过 **CSS Transition** 和 **Inline-Flex** 技术解决了“抖动”问题。

1. **加粗测试**：这是 **Bold Text**，点击这行，星号会平滑展开，而不是生硬跳出。
2. **高亮测试**：重点内容 ==Highlight Me==，我们给了它一个荧光笔背景。
3. **代码测试**：行内代码 \`console.log('Smooth')\` 也有了更好的视觉封装。

> [!tip] 交互原理
> 当你激活当前行时，为了避免布局瞬间坍塌或撑开，我们让标记符 \`max-width\` 从 0 过渡到 2ch。
> 这产生了类似“推开”文字的动画效果，虽然仍有位移，但心理感受上是“交互反馈”而非“Bug 抖动”。

## 混合排版
同时使用 **加粗** 和 ==高亮== 以及 \`代码\`。
试试在这里打字，感受光标的稳定性。
`;

// --- 样式解析器 (HTML生成) ---
const parseLineToHTML = (text) => {
  const escapeHTML = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  
  const processInline = (str) => {
    let res = escapeHTML(str);
    
    // Code: `code`
    res = res.replace(/`([^`]+)`/g, '<span class="token-formatting">`</span><code class="inline-code">$1</code><span class="token-formatting">`</span>');
    
    // Bold: **bold**
    res = res.replace(/\*\*(.*?)\*\*/g, '<span class="token-formatting">**</span><strong class="inline-bold">$1</strong><span class="token-formatting">**</span>');
    
    // Italic: *italic*
    res = res.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span class="token-formatting">*</span><em class="inline-italic">$1</em><span class="token-formatting">*</span>');
    
    // Highlight: ==highlight== (新增)
    res = res.replace(/==(.*?)==/g, '<span class="token-formatting">==</span><mark class="inline-highlight">$1</mark><span class="token-formatting">==</span>');
    
    // Link: [[link]]
    res = res.replace(/\[\[(.*?)\]\]/g, '<span class="token-formatting">[[</span><span class="internal-link">$1</span><span class="token-formatting">]]</span>');
    
    return res;
  };

  const calloutMatch = text.match(/^> \[!(\w+)\]\s*(.*)/);
  if (calloutMatch) {
    const type = calloutMatch[1].toLowerCase();
    const title = calloutMatch[2];
    const iconSVG = getCalloutIcon(type);
    
    return `
      <div class="cm-line layout-callout callout-${type}" data-callout-type="${type}">
        <span class="token-formatting token-block">&gt; [!${type}] </span>
        <div class="callout-inner">
          <span class="callout-icon">${iconSVG}</span>
          <span class="callout-title">${processInline(title || type.toUpperCase())}</span>
        </div>
      </div>
    `;
  }

  if (text.startsWith('> ')) {
    // 引用块这里也区分一下 token-block，因为它的行为是悬挂的，不同于行内 token
    return `<div class="cm-line layout-quote"><span class="token-formatting token-block">&gt;</span><span class="quote-content">${processInline(text.slice(2))}</span></div>`;
  }

  const headerMatch = text.match(/^(#{1,6})\s+(.*)/);
  if (headerMatch) {
    const level = headerMatch[1].length;
    return `<div class="cm-line layout-h${level}"><span class="token-formatting token-block level-${level} token-header">${headerMatch[1]}</span><span class="header-content">${processInline(headerMatch[2])}</span></div>`;
  }

  if (text.match(/^- /)) {
    const isDone = text.match(/^- \[x\] /);
    const isTodo = text.match(/^- \[ \] /);
    if (isDone) return `<div class="cm-line layout-list"><span class="token-formatting token-block token-list">- [x]</span><span class="token-done">${processInline(text.slice(6))}</span></div>`;
    if (isTodo) return `<div class="cm-line layout-list"><span class="token-formatting token-block token-list">- [ ]</span><span>${processInline(text.slice(6))}</span></div>`;
    return `<div class="cm-line layout-list"><span class="token-formatting token-block token-list">-</span><span>${processInline(text.slice(2))}</span></div>`;
  }

  if (text.match(/^\$\$(.*?)\$\$$/)) {
     const tex = text.match(/^\$\$(.*?)\$\$$/)[1];
     return `<div class="cm-line layout-math"><span class="token-formatting token-block">$$</span><span class="math-source">${escapeHTML(tex)}</span><span class="token-formatting token-block">$$</span></div>`;
  }

  if (text.match(/^---$/)) return `<div class="cm-line layout-hr"><span class="token-formatting token-block">---</span></div>`;

  const content = processInline(text);
  return `<div class="cm-line layout-p">${content || '<br>'}</div>`;
};

const UnifiedEditor = ({ content, onChange, readOnly = false, modeClass }) => {
  const editorRef = useRef(null);
  const contentRef = useRef(content);
  const [html, setHtml] = useState("");
  const isSelectingRef = useRef(false);

  useEffect(() => {
    if (content !== contentRef.current || html === "") {
      const newHtml = content.split('\n').map(line => parseLineToHTML(line)).join('');
      setHtml(newHtml);
      contentRef.current = content;
    }
  }, [content]);

  const handleInput = useCallback((e) => {
    if (readOnly || !editorRef.current) return;
    const lines = [];
    editorRef.current.childNodes.forEach(node => {
        if (node.nodeName === 'DIV') {
            lines.push(node.textContent);
        } else if (node.nodeName === '#text') {
            lines.push(node.textContent);
        } else if (node.nodeName === 'BR') {
            lines.push('');
        }
    });
    const newMarkdown = lines.join('\n');
    contentRef.current = newMarkdown;
    onChange(newMarkdown);
  }, [onChange, readOnly]);

  const updateActiveLines = useCallback(() => {
    if (!editorRef.current) return;
    const selection = document.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    const lines = editorRef.current.querySelectorAll('.cm-line');

    lines.forEach(line => {
        if (range.intersectsNode(line)) {
            if (!line.classList.contains('cm-focused')) {
                line.classList.add('cm-focused');
            }
        } else {
            if (line.classList.contains('cm-focused')) {
                line.classList.remove('cm-focused');
            }
        }
    });
  }, []);

  const expandSelectionToTokens = () => {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    if (range.collapsed) return;

    let modified = false;
    // 简单的选区修正逻辑
    if (range.startContainer.nodeType === 3 && range.startOffset === 0) {
      const parent = range.startContainer.parentNode;
      if (parent.tagName === 'SPAN' && parent.classList.contains('token-formatting')) {
          // 如果选区开始于 token，不做处理，允许选中 token
      } else {
          // 之前的逻辑保留
          const prev = parent.previousElementSibling;
          if (prev && prev.classList.contains('token-formatting')) {
              // 这里我们不再强制包含 Token，这会让用户感到困惑
              // range.setStartBefore(prev); 
              // modified = true;
          }
      }
    } 
    
    if (modified) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  const handleMouseDown = () => {
    if (readOnly) return;
    isSelectingRef.current = true;
    if (editorRef.current) {
        editorRef.current.classList.add('mouse-selecting');
    }
  };

  const handleMouseUp = () => {
    if (readOnly) return;
    isSelectingRef.current = false;
    if (editorRef.current) {
        editorRef.current.classList.remove('mouse-selecting');
        updateActiveLines();
    }
  };

  useEffect(() => {
    if (readOnly) return;
    const handleSelectionChange = () => {
      if (isSelectingRef.current) return;
      updateActiveLines();
    };
    document.addEventListener('selectionchange', handleSelectionChange);
    return () => document.removeEventListener('selectionchange', handleSelectionChange);
  }, [readOnly, updateActiveLines]);

  return (
    <div 
      ref={editorRef}
      className={`unified-editor ${modeClass}`}
      contentEditable={!readOnly}
      suppressContentEditableWarning={true}
      onInput={handleInput}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      spellCheck={false}
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
};

export default function ObsidianClone() {
  const [content, setContent] = useState(INITIAL_CONTENT);
  const [viewMode, setViewMode] = useState('live'); 
  const [activeFile, setActiveFile] = useState('Elegant Inline.md');
  
  useTailwind(); 
  const katexLoaded = useKaTeX();

  useEffect(() => {
    if (!katexLoaded || !window.katex) return;
    const renderMath = () => {
      document.querySelectorAll('.katex-block-render').forEach(block => {
        if (!block.innerHTML && block.dataset.expr) {
          try { window.katex.render(decodeURIComponent(block.dataset.expr), block, { displayMode: true }); } catch {}
        }
      });
    };
    renderMath();
    const interval = setInterval(renderMath, 500);
    return () => clearInterval(interval);
  }, [katexLoaded, content, viewMode]);

  const styles = `
    :root {
      --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-mono: "JetBrains Mono", "Consolas", monospace;
      --color-accent: #a882ff;
      --color-text: #dcddde;
      --color-token: #666;
      --color-highlight-bg: rgba(255, 235, 59, 0.15);
      --color-highlight-text: #fff9c4;
      --color-code-bg: rgba(255, 255, 255, 0.08);
      --color-code-text: #ff79c6;
    }

    .editor-container {
      width: 100%; max-width: 850px; margin: 0 auto; padding: 40px 60px; box-sizing: border-box;
      min-height: 80vh; cursor: text;
    }

    .unified-editor { outline: none; white-space: pre-wrap; word-break: break-word; }

    .cm-line {
      font-family: var(--font-body);
      font-size: 16px;
      line-height: 1.6;
      min-height: 1.6em; 
      margin-bottom: 2px;
      transition: color 0.2s;
      position: relative;
    }
    
    .layout-p, .layout-h1, .layout-h2, .layout-h3 { margin-bottom: 0.8em; }

    /* === 核心优化：Inline Token 的优雅处理 === */
    
    /* 1. 通用 Token 样式：默认隐藏，使用 Flex 以便控制垂直对齐 */
    .token-formatting {
      font-family: var(--font-mono);
      font-size: 0.85em;
      color: var(--color-token);
      font-weight: normal;
      
      /* 关键动画属性 */
      display: inline-flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      white-space: nowrap;
      height: 1.4em; /* 限制高度，防止撑开行高 */
      vertical-align: text-bottom;
      
      /* 初始状态：收缩 */
      max-width: 0;
      opacity: 0;
      transform: scaleX(0.8); /* 微缩放效果 */
      
      /* 丝滑的贝塞尔曲线 */
      transition: 
        max-width 0.25s cubic-bezier(0.2, 0, 0.2, 1),
        opacity 0.2s ease-out,
        transform 0.2s ease-out;
    }

    /* 2. 激活状态：平滑展开 */
    .mode-live .cm-line.cm-focused .token-formatting:not(.token-block) {
       max-width: 4ch; /* 足够容纳 **, ==, code 等 */
       opacity: 1;
       transform: scaleX(1);
       margin: 0 1px; /* 展开时给一点呼吸空间 */
    }
    
    /* 3. 悬挂 Block Token (Header, List, Quote) 保持绝对定位不变 */
    .token-block {
       /* 覆盖上面的 inline-flex 动画逻辑，保持绝对定位逻辑 */
       transition: none !important; 
       max-width: none !important;
       transform: none !important;
       overflow: visible !important;
       /* Block token 的显示由之前的逻辑控制（display: none/block/absolute） */
    }
    .mode-live .token-block { display: none; }
    .mode-live .cm-line.cm-focused .token-block { display: inline-block; }


    /* === 美化 Inline 内容样式 === */
    
    /* Strong */
    .inline-bold {
      color: #fff;
      font-weight: 700;
    }

    /* Highlight (==) */
    .inline-highlight {
      background-color: var(--color-highlight-bg);
      color: var(--color-highlight-text);
      border-radius: 4px;
      padding: 0 2px;
      box-decoration-break: clone; /* 换行时保持圆角 */
      -webkit-box-decoration-break: clone;
      border-bottom: 1px solid rgba(255, 235, 59, 0.3);
    }

    /* Inline Code */
    .inline-code {
      background: var(--color-code-bg);
      color: var(--color-code-text);
      padding: 0.1em 0.4em;
      border-radius: 4px;
      font-family: var(--font-mono);
      font-size: 0.85em;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    /* Link ([[]]) */
    .internal-link {
      color: var(--color-accent);
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    /* === Block Layout (Re-applied from previous step) === */
    .mode-live .layout-h1 .token-header,
    .mode-live .layout-h2 .token-header,
    .mode-live .layout-h3 .token-header {
       position: absolute; right: 100%; top: 0; margin-right: 12px; text-align: right; min-width: 60px;
    }
    .layout-list { padding-left: 24px; }
    .mode-live .layout-list .token-list { position: absolute; left: 0; width: 24px; text-align: center; }
    .layout-quote { position: relative; padding-left: 16px; }
    .mode-live .layout-quote.cm-focused .token-formatting.token-block { position: absolute; left: -15px; width: 15px; text-align: center; }

    /* Callout & Others */
    .layout-callout { margin-top: 1em; background: rgba(30, 30, 30, 0.5); }
    .callout-inner { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; width: 100%; border-radius: 4px 4px 0 0; background: rgba(255, 255, 255, 0.05); border-left: 4px solid var(--color-token); box-sizing: border-box; }
    .callout-info .callout-inner { border-left-color: var(--callout-info); background: rgba(0, 176, 255, 0.1); } .callout-info .callout-icon { color: var(--callout-info); }
    .layout-quote { margin-bottom: 0; padding: 2px 16px; background: rgba(255, 255, 255, 0.02); border-left: 4px solid #444; }
    .mode-live .cm-line.layout-callout.cm-focused .callout-inner { display: none; }
    .mode-live .cm-line.layout-callout.cm-focused .token-formatting:not(.token-block) { display: inline-flex; } /* 这里的 token-formatting 指的是 > [!info] 里的文本 */

    /* Source & Reading Mode Overrides */
    .mode-source .token-formatting { max-width: none !important; opacity: 1 !important; transform: none !important; width: auto; display: inline; }
    .mode-source .token-block { display: inline !important; position: static !important; }
    .mode-source .cm-line { padding-left: 0 !important; }
    
    .mode-reading .token-formatting { display: none !important; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  `;

  return (
    <div className="flex flex-col h-screen w-full bg-[#1e1e1e] text-[#dcddde] overflow-hidden font-sans select-none">
      <style>{styles}</style>
      
      <div className="h-9 flex items-center bg-[#111] border-b border-[#333] px-2 text-xs">
         <div className="flex gap-2 mr-4 opacity-50"><div className="w-3 h-3 rounded-full bg-red-500"></div><div className="w-3 h-3 rounded-full bg-yellow-500"></div><div className="w-3 h-3 rounded-full bg-green-500"></div></div>
         <span className="opacity-60 flex-1 text-center">Obsidian Clone - {activeFile}</span>
      </div>

      <div className="flex flex-1 overflow-hidden">
        <div className="w-64 bg-[#202020] border-r border-[#333] hidden md:flex flex-col">
           <div className="p-3 text-sm text-[#999] font-bold flex items-center gap-2"><Folder size={16}/> 笔记库</div>
           <div className="px-2">
             <div className="bg-[#353b48] text-white p-1 rounded text-sm flex gap-2 border-l-2 border-[#a882ff]"><FileText size={14}/> {activeFile}</div>
           </div>
        </div>

        <div className="flex-1 flex flex-col bg-[#1e1e1e]">
          <div className="h-10 border-b border-[#333] flex items-center px-4 justify-between bg-[#1e1e1e]">
             <span className="text-sm font-bold flex items-center gap-2"><FileText size={16} className="text-[#a882ff]"/> {activeFile}</span>
             <div className="flex bg-[#111] rounded border border-[#333] p-0.5">
                <button onClick={() => setViewMode('source')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='source'?'bg-[#333] text-white':'text-[#666]'}`}><Hash size={12}/> 源码</button>
                <button onClick={() => setViewMode('live')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='live'?'bg-[#333] text-white':'text-[#666]'}`}><Edit3 size={12}/> 实时</button>
                <button onClick={() => setViewMode('reading')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='reading'?'bg-[#333] text-white':'text-[#666]'}`}><Eye size={12}/> 阅读</button>
             </div>
          </div>

          <div className="flex-1 overflow-y-auto relative w-full">
            <div className="w-full flex justify-center">
              <div className="editor-container">
                <UnifiedEditor 
                  content={content} 
                  onChange={setContent} 
                  readOnly={viewMode === 'reading'}
                  modeClass={`mode-${viewMode}`}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}