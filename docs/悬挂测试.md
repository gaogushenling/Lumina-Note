import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FileText, 
  Edit3, 
  Eye, 
  Folder, 
  Hash,
  AlertCircle,
  CheckCircle2,
  Flame,
  Info,
  Zap
} from 'lucide-react';

// --- Tailwind Loader (Fix for ReferenceError) ---
const useTailwind = () => {
  useEffect(() => {
    // 检查 tailwind 是否已存在，不存在则注入 CDN
    if (window.tailwind) return;
    
    const script = document.createElement('script');
    script.src = "https://cdn.tailwindcss.com";
    script.async = true;
    script.onload = () => {
       // Optional: 配置一些默认主题扩展，如果有需要的话
       // window.tailwind.config = { ... } 
    };
    document.head.appendChild(script);
  }, []);
};

// --- KaTeX Loader ---
const useKaTeX = () => {
  const [isLoaded, setIsLoaded] = useState(false);
  useEffect(() => {
    if (window.katex) { setIsLoaded(true); return; }
    const link = document.createElement('link');
    link.href = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css";
    link.rel = "stylesheet";
    document.head.appendChild(link);
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js";
    script.onload = () => setIsLoaded(true);
    document.head.appendChild(script);
  }, []);
  return isLoaded;
};

// --- SVG Icons Map for Callouts (Inline String Version) ---
const getCalloutIcon = (type) => {
  const icons = {
    note: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>',
    info: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>',
    tip: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.5-3.3"/></svg>',
    success: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
    warning: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></svg>',
    danger: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><line x1="15" x2="9" y1="9" y2="15"/><line x1="9" x2="15" y1="9" y2="15"/></svg>',
    example: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>'
  };
  return icons[type] || icons.note;
};

const INITIAL_CONTENT = `## ✨ 完美的悬挂布局

现在，点击任何标题或列表，你会发现**正文完全不会抖动**。

# 一级标题测试 (H1)
试着点击这一行。你会看到 \`#\` 符号静静地出现在左侧，而文字纹丝不动。

- [ ] 列表项测试 1
- [x] 列表项测试 2
  - 缩进列表测试

> 引用块测试
> 点击这里，\>\ 符号会浮现在边框左侧。

> [!info] Callout 提示
> Callout 的行为比较特殊，因为涉及到整个 DOM 结构的变换，但在源码模式下依然遵循悬挂原则。

## 核心技术细节
1. **绝对定位 (Absolute Positioning)**：将 \`#\`、\`-\` 等 Token 移出文档流。
2. **Padding 预留**：给容器预留左侧空间，确保文字始终对齐。
3. **视觉零干扰**：标识符显示时，完全不挤占正文空间。
`;

// --- 样式解析器 (HTML生成) ---
const parseLineToHTML = (text) => {
  const escapeHTML = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  
  const processInline = (str) => {
    let res = escapeHTML(str);
    res = res.replace(/`([^`]+)`/g, '<span class="token-formatting">`</span><code class="inline-code">$1</code><span class="token-formatting">`</span>');
    res = res.replace(/\*\*(.*?)\*\*/g, '<span class="token-formatting">**</span><strong>$1</strong><span class="token-formatting">**</span>');
    res = res.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span class="token-formatting">*</span><em>$1</em><span class="token-formatting">*</span>');
    res = res.replace(/\[\[(.*?)\]\]/g, '<span class="token-formatting">[[</span><span class="internal-link">$1</span><span class="token-formatting">]]</span>');
    return res;
  };

  const calloutMatch = text.match(/^> \[!(\w+)\]\s*(.*)/);
  if (calloutMatch) {
    const type = calloutMatch[1].toLowerCase();
    const title = calloutMatch[2];
    const iconSVG = getCalloutIcon(type);
    
    return `
      <div class="cm-line layout-callout callout-${type}" data-callout-type="${type}">
        <span class="token-formatting">&gt; [!${type}] </span>
        <div class="callout-inner">
          <span class="callout-icon">${iconSVG}</span>
          <span class="callout-title">${processInline(title || type.toUpperCase())}</span>
        </div>
      </div>
    `;
  }

  if (text.startsWith('> ')) {
    return `<div class="cm-line layout-quote"><span class="token-formatting">&gt;</span><span class="quote-content">${processInline(text.slice(2))}</span></div>`;
  }

  const headerMatch = text.match(/^(#{1,6})\s+(.*)/);
  if (headerMatch) {
    const level = headerMatch[1].length;
    // 注意：这里我们给 # 加上 text-align right 样式类辅助
    return `<div class="cm-line layout-h${level}"><span class="token-formatting level-${level} token-header">${headerMatch[1]}</span><span class="header-content">${processInline(headerMatch[2])}</span></div>`;
  }

  if (text.match(/^- /)) {
    const isDone = text.match(/^- \[x\] /);
    const isTodo = text.match(/^- \[ \] /);
    if (isDone) return `<div class="cm-line layout-list"><span class="token-formatting token-list">- [x]</span><span class="token-done">${processInline(text.slice(6))}</span></div>`;
    if (isTodo) return `<div class="cm-line layout-list"><span class="token-formatting token-list">- [ ]</span><span>${processInline(text.slice(6))}</span></div>`;
    return `<div class="cm-line layout-list"><span class="token-formatting token-list">-</span><span>${processInline(text.slice(2))}</span></div>`;
  }

  if (text.match(/^\$\$(.*?)\$\$$/)) {
     const tex = text.match(/^\$\$(.*?)\$\$$/)[1];
     return `<div class="cm-line layout-math"><span class="token-formatting">$$</span><span class="math-source">${escapeHTML(tex)}</span><span class="token-formatting">$$</span></div>`;
  }

  if (text.match(/^---$/)) return `<div class="cm-line layout-hr"><span class="token-formatting">---</span></div>`;

  const content = processInline(text);
  return `<div class="cm-line layout-p">${content || '<br>'}</div>`;
};

const UnifiedEditor = ({ content, onChange, readOnly = false, modeClass }) => {
  const editorRef = useRef(null);
  const contentRef = useRef(content);
  const [html, setHtml] = useState("");
  const isSelectingRef = useRef(false);

  useEffect(() => {
    if (content !== contentRef.current || html === "") {
      const newHtml = content.split('\n').map(line => parseLineToHTML(line)).join('');
      setHtml(newHtml);
      contentRef.current = content;
    }
  }, [content]);

  const handleInput = useCallback((e) => {
    if (readOnly || !editorRef.current) return;
    const lines = [];
    editorRef.current.childNodes.forEach(node => {
        if (node.nodeName === 'DIV') {
            lines.push(node.textContent);
        } else if (node.nodeName === '#text') {
            lines.push(node.textContent);
        } else if (node.nodeName === 'BR') {
            lines.push('');
        }
    });
    const newMarkdown = lines.join('\n');
    contentRef.current = newMarkdown;
    onChange(newMarkdown);
  }, [onChange, readOnly]);

  const updateActiveLines = useCallback(() => {
    if (!editorRef.current) return;
    const selection = document.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    const lines = editorRef.current.querySelectorAll('.cm-line');

    lines.forEach(line => {
        if (range.intersectsNode(line)) {
            if (!line.classList.contains('cm-focused')) {
                line.classList.add('cm-focused');
            }
        } else {
            if (line.classList.contains('cm-focused')) {
                line.classList.remove('cm-focused');
            }
        }
    });
  }, []);

  const expandSelectionToTokens = () => {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    const range = selection.getRangeAt(0);
    if (range.collapsed) return;

    let modified = false;
    if (range.startContainer.nodeType === 3 && range.startOffset === 0) {
      const parent = range.startContainer.parentNode;
      if (['STRONG', 'EM', 'CODE', 'SPAN'].includes(parent.tagName)) {
         const prev = parent.previousElementSibling;
         if (prev && prev.classList.contains('token-formatting')) {
             range.setStartBefore(prev);
             modified = true;
         }
      }
    } 
    
    if (range.endContainer.nodeType === 3 && range.endOffset === range.endContainer.length) {
       const parent = range.endContainer.parentNode;
       if (['STRONG', 'EM', 'CODE', 'SPAN'].includes(parent.tagName)) {
          const next = parent.nextElementSibling;
          if (next && next.classList.contains('token-formatting')) {
              range.setEndAfter(next);
              modified = true;
          }
       }
    }

    if (modified) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  const handleMouseDown = () => {
    if (readOnly) return;
    isSelectingRef.current = true;
    if (editorRef.current) {
        editorRef.current.classList.add('mouse-selecting');
    }
  };

  const handleMouseUp = () => {
    if (readOnly) return;
    isSelectingRef.current = false;
    if (editorRef.current) {
        editorRef.current.classList.remove('mouse-selecting');
        updateActiveLines();
        setTimeout(() => {
            expandSelectionToTokens();
        }, 0);
    }
  };

  useEffect(() => {
    if (readOnly) return;
    const handleSelectionChange = () => {
      if (isSelectingRef.current) return;
      updateActiveLines();
    };
    document.addEventListener('selectionchange', handleSelectionChange);
    return () => document.removeEventListener('selectionchange', handleSelectionChange);
  }, [readOnly, updateActiveLines]);

  return (
    <div 
      ref={editorRef}
      className={`unified-editor ${modeClass}`}
      contentEditable={!readOnly}
      suppressContentEditableWarning={true}
      onInput={handleInput}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      spellCheck={false}
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
};

export default function ObsidianClone() {
  const [content, setContent] = useState(INITIAL_CONTENT);
  const [viewMode, setViewMode] = useState('live'); 
  const [activeFile, setActiveFile] = useState('Layout Fix.md');
  
  // 激活 Hooks
  useTailwind(); 
  const katexLoaded = useKaTeX();

  useEffect(() => {
    if (!katexLoaded || !window.katex) return;
    const renderMath = () => {
      document.querySelectorAll('.katex-block-render').forEach(block => {
        if (!block.innerHTML && block.dataset.expr) {
          try { window.katex.render(decodeURIComponent(block.dataset.expr), block, { displayMode: true }); } catch {}
        }
      });
    };
    renderMath();
    const interval = setInterval(renderMath, 500);
    return () => clearInterval(interval);
  }, [katexLoaded, content, viewMode]);

  const styles = `
    :root {
      --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-mono: "JetBrains Mono", "Consolas", monospace;
      --color-accent: #a882ff;
      --color-text: #dcddde;
      --color-token: #666;
      
      /* Callout Colors */
      --callout-info: #00b0ff;
      --callout-note: #00b0ff;
      --callout-tip: #00c853;
      --callout-success: #00c853;
      --callout-warning: #ff9100;
      --callout-danger: #ff5252;
      --callout-error: #ff5252;
      --callout-example: #7e57c2;
    }

    .editor-container {
      width: 100%; max-width: 850px; margin: 0 auto; padding: 40px 60px; box-sizing: border-box;
      min-height: 80vh; cursor: text;
    }

    .unified-editor { outline: none; white-space: pre-wrap; word-break: break-word; }

    .cm-line {
      font-family: var(--font-body);
      font-size: 16px;
      line-height: 1.6;
      min-height: 1.6em; 
      margin-bottom: 2px;
      transition: color 0.2s;
      position: relative; /* 关键：作为绝对定位的锚点 */
    }
    
    .layout-p, .layout-h1, .layout-h2, .layout-h3 { margin-bottom: 0.8em; }

    .token-formatting {
      font-family: var(--font-mono);
      font-size: 0.85em;
      color: var(--color-token);
      margin: 0 1px;
      vertical-align: baseline;
      font-weight: normal;
    }

    /* === 悬挂布局核心逻辑 (Hanging Layout) === */
    /* 核心思想：内容始终保持缩进状态，Token 使用绝对定位悬浮在左侧 Gutter 中 */
    
    /* 1. 默认隐藏所有 Token (Live Mode) */
    .mode-live .token-formatting { display: none; }
    
    /* 2. 激活时显示 Token，但使用 Absolute Positioning */
    .mode-live .cm-line.cm-focused .token-formatting {
       display: inline-block;
       /* 对于行内元素 (**bold**)，我们不强制 absolute，否则会重叠。
          Absolute 只应用于那些会导致整行重排的 Block 元素 (Headers, Lists, Quotes) */
    }

    /* --- Headers (#) --- */
    /* 永远不在内容流中占用空间 */
    .mode-live .layout-h1 .token-header,
    .mode-live .layout-h2 .token-header,
    .mode-live .layout-h3 .token-header {
       position: absolute;
       right: 100%; /* 位于内容左边缘 */
       top: 0;
       margin-right: 12px;
       text-align: right;
       min-width: 60px; /* 保证 # 有足够点击区域 */
       /* 覆盖上面的 display 规则：只要 Focused，就显示 */
    }

    /* --- Lists (-) --- */
    .layout-list {
       /* 永久左 padding，确保文字位置固定，不论是否有 bullet */
       padding-left: 24px; 
    }
    .mode-live .layout-list .token-list {
       position: absolute;
       left: 0;
       width: 24px;
       text-align: center;
    }
    
    /* --- Quotes (>) --- */
    .layout-quote {
       position: relative;
       padding-left: 16px; /* 调整 padding 以容纳 > */
    }
    .mode-live .layout-quote .token-formatting {
       /* 引用块比较特殊，> 通常紧贴边框 */
    }
    /* 单独处理 Quote 的 > */
    .mode-live .layout-quote.cm-focused .token-formatting {
       position: absolute;
       left: -15px; /* 悬浮在 Border 左侧 */
       width: 15px;
       text-align: center;
    }


    /* === Callout Styling === */
    .layout-callout {
      margin-top: 1em;
      margin-bottom: 0;
      background: rgba(30, 30, 30, 0.5);
    }
    .callout-inner {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      width: 100%;
      border-radius: 4px 4px 0 0;
      background: rgba(255, 255, 255, 0.05);
      border-left: 4px solid var(--color-token);
      box-sizing: border-box;
    }
    .callout-icon { display: flex; align-items: center; }
    .callout-title { font-weight: 600; font-size: 0.95em; }

    .callout-info .callout-inner, .callout-note .callout-inner { border-left-color: var(--callout-info); background: rgba(0, 176, 255, 0.1); }
    .callout-info .callout-icon, .callout-info .callout-title { color: var(--callout-info); }
    
    .callout-tip .callout-inner, .callout-success .callout-inner { border-left-color: var(--callout-tip); background: rgba(0, 200, 83, 0.1); }
    .callout-tip .callout-icon, .callout-tip .callout-title { color: var(--callout-tip); }

    .callout-warning .callout-inner { border-left-color: var(--callout-warning); background: rgba(255, 145, 0, 0.1); }
    .callout-warning .callout-icon, .callout-warning .callout-title { color: var(--callout-warning); }

    .callout-danger .callout-inner, .callout-error .callout-inner { border-left-color: var(--callout-danger); background: rgba(255, 82, 82, 0.1); }
    .callout-danger .callout-icon, .callout-danger .callout-title { color: var(--callout-danger); }

    .callout-example .callout-inner { border-left-color: var(--callout-example); background: rgba(126, 87, 194, 0.1); }
    .callout-example .callout-icon, .callout-example .callout-title { color: var(--callout-example); }

    .layout-quote {
      margin-bottom: 0;
      padding: 2px 16px 2px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-left: 4px solid #444;
    }
    
    /* Live Mode Callout Behavior */
    .mode-live .cm-line.layout-callout.cm-focused .callout-inner { display: none; }
    .mode-live .cm-line.layout-callout.cm-focused .token-formatting { display: inline; color: var(--color-accent); }
    
    .mode-live.unified-editor.mouse-selecting .token-formatting { display: none !important; }
    .mode-live.unified-editor.mouse-selecting .callout-inner { display: inline-flex !important; }

    .mode-source .token-formatting { display: inline !important; color: var(--color-accent); opacity: 0.8; position: static; }
    .mode-source .callout-inner { display: none; }
    .mode-source .cm-line { padding-left: 0 !important; } /* Source 模式下取消缩进 */

    .mode-reading .token-formatting { display: none !important; }
    .mode-reading .cm-line { cursor: default; }

    .layout-h1 { font-size: 2em; font-weight: 700; color: #fff; margin-top: 1.5em; border-bottom: 1px solid #333; padding-bottom: 0.3em; }
    .layout-h2 { font-size: 1.6em; font-weight: 600; color: #58a6ff; margin-top: 1.4em; }
    .layout-h3 { font-size: 1.3em; font-weight: 600; color: #fff; margin-top: 1.2em; }
    
    .inline-code { background: rgba(255,255,255,0.1); padding: 0.2em 0.4em; border-radius: 4px; font-family: var(--font-mono); color: #ff79c6; font-size: 0.9em; }
    .internal-link { color: var(--color-accent); text-decoration: underline; }
    .token-done { text-decoration: line-through; opacity: 0.6; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  `;

  return (
    <div className="flex flex-col h-screen w-full bg-[#1e1e1e] text-[#dcddde] overflow-hidden font-sans select-none">
      <style>{styles}</style>
      
      <div className="h-9 flex items-center bg-[#111] border-b border-[#333] px-2 text-xs">
         <div className="flex gap-2 mr-4 opacity-50"><div className="w-3 h-3 rounded-full bg-red-500"></div><div className="w-3 h-3 rounded-full bg-yellow-500"></div><div className="w-3 h-3 rounded-full bg-green-500"></div></div>
         <span className="opacity-60 flex-1 text-center">Obsidian Clone - {activeFile}</span>
      </div>

      <div className="flex flex-1 overflow-hidden">
        <div className="w-64 bg-[#202020] border-r border-[#333] hidden md:flex flex-col">
           <div className="p-3 text-sm text-[#999] font-bold flex items-center gap-2"><Folder size={16}/> 笔记库</div>
           <div className="px-2">
             <div className="bg-[#353b48] text-white p-1 rounded text-sm flex gap-2 border-l-2 border-[#a882ff]"><FileText size={14}/> {activeFile}</div>
           </div>
        </div>

        <div className="flex-1 flex flex-col bg-[#1e1e1e]">
          <div className="h-10 border-b border-[#333] flex items-center px-4 justify-between bg-[#1e1e1e]">
             <span className="text-sm font-bold flex items-center gap-2"><FileText size={16} className="text-[#a882ff]"/> {activeFile}</span>
             <div className="flex bg-[#111] rounded border border-[#333] p-0.5">
                <button onClick={() => setViewMode('source')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='source'?'bg-[#333] text-white':'text-[#666]'}`}><Hash size={12}/> 源码</button>
                <button onClick={() => setViewMode('live')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='live'?'bg-[#333] text-white':'text-[#666]'}`}><Edit3 size={12}/> 实时</button>
                <button onClick={() => setViewMode('reading')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='reading'?'bg-[#333] text-white':'text-[#666]'}`}><Eye size={12}/> 阅读</button>
             </div>
          </div>

          <div className="flex-1 overflow-y-auto relative w-full">
            <div className="w-full flex justify-center">
              <div className="editor-container">
                <UnifiedEditor 
                  content={content} 
                  onChange={setContent} 
                  readOnly={viewMode === 'reading'}
                  modeClass={`mode-${viewMode}`}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}